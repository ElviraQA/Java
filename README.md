### Теория по блоку "Базовый синтаксис"
 
 #### 1. Что такое виртуальная машина? 
 Виртуальная машина это программа выполняющая наше написанное ПО под конкретную платформу. 
 Т.е. переводит наш скомпилированный байт-код в машинные операции.

 #### 2. К какому типу языка программирования относится Java?
 Язык Java это компилируемо-интерпретируемый язык. Написанный нами код компилируется в так называемый байт-код,
 а он в свою очередь уже подается в интерпретатор(Виртуальная машина) 
 
 #### 3. Из каких компонентов состоит Java (JDK, JRE, JVM)?
 Java состоит из компилятора языка, виртуальной машины и различных библиотек и утилит.
 
 #### 4. Для чего используется JDK?
 JDK - это Java Development Kit, т.е. набор для разработки ПО. Он включает в себя
 компилятор(javac), JRE (Java runtime environment) - виртуальная машина и набор библиотек.
 Т.е. JDK используется для разработки и запуска пограммного обеспечения.
 
 #### 5. Для чего используется JRE?
 JRE(Java runtime environment) - обеспечивает выполнение Java-программы на любой аппаратной платформе и на любой ОС.
 Включает в себя виртуальную машину(VM) и набор стандартных библиотек.
 
 #### 6. Для чего используется VM?
 VM (Virtual Machine) - виртуальная машина служит для запуска Java-программы на конкретной платформе пользователя.
 
 #### 7. Расскажите про примитивные типы.
 Примитивные: boolean, byte, short, char, int, long, float, double.
 Это типы хранящие заданное значение, они содержат данные.
 Они разделяются на логичекий тип(boolean), целочисленные(short, byte, int, long), с плавающей точкой(float, double)
 и символьный(char).
 
 #### 8. Опишите шаги для компиляции и запуска приложения в консоли (javac java).
 Создаем класс - файл с классом с расширением *.java.
 Запускаем компилятор javac, где указываем что компилируем и куда отправть результат.
 На выходе получаем файл с таким же названием как на входе, но с расширением *.class - это и есть байт код.
 
 #### 9. Что такое "оператор условия"?
 Это операторы(ключевые слова языка) создающие ветвление алгоритма программ.
 Ветвление — это алгоритмическая конструкция, в которой в зависимости от истинности некоторого условия, выполняется 
 одна из нескольких последовательностей действий.
 
 #### 10. Какие типы операторов условия существуют?
 В языке программирования Java существует три условных оператора:
 
 if() — если…, оно же основное логическое условие;
 else if() — альтернативное условие, выполняется если не выполнилось основное;
 else — иначе…, выполняется в случае, если ни одно из вышеприведённых условий не было выполнено.
 В круглых скобках указывается логическое условие. В else круглые скобки не требуются, так как это условие выполняется 
 в случае, если ни одно из условий выполнено не было.
 
 Условные операторы помещаются в условный блок.
 Условный блок — это контейнер, содержащий в себе набор условных операторов и логических выражений.
 Условных блоков (контейнеров) в программе может быть сколько угодно.
 Для каждого условного блока существуют следующие правила:
 
 if() — только один и является обязательным, требуется логическое выражение в скобках;
 else if() — сколько угодно и обязательным не является, требуется логическое выражение в скобках;
 else — только один и обязательным не является, логическое выражение не требуется;
 
 #### 11. Расскажите про булевы операции || &&?  Расскажите элементы таблицы истинности?
 || - логическое ИЛИ, результат будет True хотя бы один операнд True. Еще называют логической дизъюнкцией или логическим
 сложением.
 && - логическое И, результат будет False хотя бы один операнд False. Еще называют логической конъюнкцией, или логическим 
 умнжением.
 
 #### 12. Что такое тернарное условие?
 Тернарный оператор (от латинского слова ternarius — тройной)- это оператор, состоящий из двух символов '?' и ':', 
 который формирует условную тернарную операцию, возвращающую свой второй или третий операнд в зависимости от 
 выполнения или невыполнения определённого условия, или другими словами от результата логического выражения.
 
 #### 13. Что такое циклы и для чего они используются?
 Цикл — это конструкция, содержащая в себе программный код, который должен быть выполнен определённое количество раз.
 Ипользуется, когда нужно выполнить какое-то действие определенное количество раз.
 
 #### 14. Для чего используется цикл for?
 Цикл for еще называют цикл "со счетчиком". Используется он для повторения действия, когда заранее известно количество 
 повторений. "Для такого диапазона мы делаем что-то."
 
 #### 15. Для чего используется цикл foreach?
 Цикл используется при работе с массивами, коллекциями и другии объектами.
 При этом цикл выполняется кол-во раз равное кол-ву элементов. "Для всех в массиве мы делаем что-то."
 
 #### 16. Для чего используется цикл while?
 Цикл Выполняется пока условие истинно.
 Нужен для многократного повторения, когда мы не значем требуемого кол-ва итераций, а дожидаемся конкретного
 условия. "Делаем что-то пока не выполнится условие".
 
 #### 17. Для чего используется цикл do while?
 Этот цикл выполняется так же, если мы не знаем требуемое кол-во итераций.
 Но этот цикл с пост условием, т.е. тело цикло выполнится хотя бы один раз.
 
 #### 18. Что такое массив?
 Массив — это структура данных, в которой хранятся элементы одного типа. Его можно представить, как набор 
 пронумерованных ячеек, в каждую из которых можно поместить какие-то данные (один элемент данных в одну ячейку). 
 Доступ к конкретной ячейке осуществляется через её номер. Номер элемента в массиве также называют индексом. 
 
 #### 19. Как создать массив? 
 Создаем переменную ссылочного типа на массив и ссылаем её на созданный объект массива заданного количества элементов.
 int[] array = new int[10];
 Так же можно не указывать кол-в элементов, а сразу их объявить.
 int[] array = new int[]{1, 2, 3};

 #### 20. Как присвоить значение ячейке массива?
 Для заполнения ячейки массива используется следующая конструкция.
 Имя_Переменной_Массива[Индекс] = Значение;
 nums[0] = 2006;
 nums[1] = 2010; 
 То есть, нужно обратиться к ячейке по ее индексу.
 
 #### 21. Как можно пройти по всем элементам массива?
 С помощью цикла foreach
 
 #### 22. Как можно найти элемент в массиве?
 С помощью цикла и условных операторов.
 
 #### 23. Что будет, если записывать элемент по индексу -1?
 Выход за границу массива. Программа выдаст ошибку.
 
 #### 24. Как удалить ячейку в массиве?
 Ячейку удалить нельзя, но можно обнулить ее значение или ссылку на объект, которую она содержала.
 
 #### 25. Как отредактировать ячейку в массиве?
 Так же как и присвоить ей значение.новое значение. Индексирование массива начинается с нуля.
 
 array[0] = 10;
 array[0] = 20;
 
* **[Тестовое задание](https://github.com/ShalopaykaQA/games_oop_javafx/commit/13b73911c578c50ea0934040f3fcdd1ccb8846b7) по итогам блока.**
## OOP

[1. Что такое ООП?](#1-Что-такое-ООП)

[2. Базовые концепции ООП?](#2-Базовые-концепции-ООП)

[3. Укажите из каких элементов состоит класс?](#3-Укажите-из-каких-элементов-состоит-класс)

[4. Что такое конструктор? Типы конструкторов?](#4-Что-такое-конструктор-Типы-конструкторов)

[5. Можно ли наследовать конструктор?](#5-Можно-ли-наследовать-конструктор)

[6. Что такое перегрузка конструктора?](#6-Что-такое-перегрузка-конструктора)

[7. Что такое статический метод?](#7-Что-такое-статический-метод)

[8. Что такое нестатический метод?](#8-Что-такое-не-статический-метод)

[9. Для чего используется ключевое слово this?](#9-Для-чего-используется-ключевое-слово-this)

[10. Какой класс является базовым родительским классом для всех классов?](#10-Какой-класс-является-базовым-родительским-классом-для-всех-классов)

[11. Что такое наследование? Приведите примеры из реальной жизни?](#11-Что-такое-наследование-Приведите-примеры-из-реальной-жизни)

[12. Опишите процесс создания нового объекта.](#12-Опишите-процесс-создания-нового-объекта)

[13. Как вызвать метод из родительского класса?](#13-Как-вызвать-метод-из-родительского-класса)

[14. Что такое переопределение метода?](#14-Что-такое-переопределение-метода)

[15. Можно ли переопределить статический метод?](#15-Можно-ли-переопределить-статический-метод)

[16. Что такое виртуальная функция и используются ли они в Java?](#16-Что-такое-виртуальная-функция-и-используются-ли-они-в-Java)

[17. Что такое перегрузка метода?](#17-Что-такое-перегрузка-метода)

[18. Можно ли изменить тип возвращаемых тип данных при перегрузке метода?](#18-Можно-ли-изменить-тип-возвращаемых-тип-данных-при-перегрузке-метода)

[19. Что такое множественное наследование? Как его можно реализовать в Java?](#19-Что-такое-множественное-наследование-Как-его-можно-реализовать-в-Java)

[20. Что такое полиморфизм? Приведите примеры из реальной жизни?](#20-Что-такое-полиморфизм-Приведите-примеры-из-реальной-жизни)

[21. Что такое инкапсуляция?](#21-Что-такое-инкапсуляция)

[22. Как реализована инкапсуляция в Java?](#22-Как-реализована-инкапсуляция-в-Java)

[23. Можно ли применять модификаторы доступа к конструкторам?](#23-Можно-ли-применять-модификаторы-досутпа-к-конструкторам)

[24. Что такое интерфейс?](#24-Что-такое-интерфейс)

[25. Какие типы исключительных ситуаций бывают?](#25-Какие-типы-исключительных-ситуаций-бывают)

[26. Назовите основные методы класса Object?](#26-Назовите-основные-методы-класса-Object)

[27. Что такое шаблоны проектирования?](#27-Что-такое-шаблоны-проектирования)

[28. Объясните шаблон Декоратор?](#28-Объясните-шаблон-Декоратор)

[29. Объясните шаблон Стратегия?](#29-Объясните-такое-композиция)

## 1. Что такое ООП?

Подход (методология) к программированию ориентированный на объекты. Представление программы в виде совокупности объектов, 
каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Важным элементом ООП является абстракция. Эффективным средством применения абстракции служат иерархические конструкции.
Это позволяет упрощать понимание сложных систем, разбивая их на более управляемые части.

Например, внешне автомобиль выглядит единым объектом. Но внутрион состоит из нескольких подсистем: 
рулевого управления, двигатель, тормоза, аудиосистемы и т.п. 
Каждая из этих подсистем, также собрана из более специализированных узлов. 
Т.е. структуру автомобиля (или любой сложной системы) можно описать с помощью иерархических абстракций.
Это применимо и к компьютерным программам.

Суть ООП - с помощью абстракций организовать данные компьютерной программы в виде объектов, а последовательность этапов 
ее выполнения — в совокупность сообщений, передаваемых между этими объектами. Т.е. каждый из этих объектов описывает 
свое особое поведение. Эти объекты можно считать конкретными сущностями, реагирующими на сообщения, 
предписывающие им выполнить конкретное действие. 

https://oracle-patches.com/coding/3720-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%BE%D0%BF

[к оглавлению](#OOP)

## 2. Базовые концепции ООП?

+ **Инкапсуляция** - свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. 
Для Java корректно будет говорить, что инкапсуляция это «сокрытие реализации».

+ **Наследование** - свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью 
заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским 
или суперклассом.

+ **Полиморфизм** - свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней 
структуре объекта.

+ **Абстракция** - выделение значимой информации и исключение из рассмотрения незначимой.

[к оглавлению](#OOP)

## 3. Укажите из каких элементов состоит класс?

Класс состоит из полей (атрибуты) и методов (функции для работы с этими полями). 
Поле (атрибут) класса — это характеристика объекта, содержит его состояние. 
Например для фигуры это может быть название, площадь, периметр.

Класс является ссылочным типом данных. Это шаблон для создания объекта, в свою очередь объект - это экземпляр класса.

Типы полей:

+ локальные переменные - определены внутри методов, конструкторов или иных блоков кода (циклы, итераторы и т.д.)
Они объявляются и уничтожаются по завершении работы метода.

+ переменные экземпляра - доступны в пределах класса и из любого метода, конструктора или иных блоков кода 
конкретного класса (циклы, итераторы и т.д.).

+ статические переменные - объявляются в классе вне любого метода с помощью ключевого слова `static`.

[к оглавлению](#OOP)

## 4. Что такое конструктор Типы конструкторов?

**Конструктор** — это специальный метод, который вызывается при создании нового объекта (всегда вызывается совместно с 
операцией `new`).
 
Конструктор нужен для автоматической инициализации переменных, т.е. он инициализирует объект непосредственно во время создания. 
Имя конструктора совпадает с именем класса, включая регистр, 
а по синтаксису конструктор похож на метод без возвращаемого значения `void`.

Существуют:

+ конструктор по умолчанию или неявный (без параметров - позволяет регулировать, какие параметры и в каком количестве
нужно задать для создания объекта определенного класса).

+ конструктор с параметрами или явный.

[к оглавлению](#OOP)

## 5. Можно ли наследовать конструктор?

Нет, но ему можно передать аргументы с помощью `super`.

В Java подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса.
Конструкторы не являются членами, поэтому они не наследуются, но конструктор суперкласса м.б. вызван из подкласса.

[к оглавлению](#OOP)

## 6. Что такое перегрузка конструктора?

**Перегрузка конструктора** - это создание конструкторов с другим набором аргументов (как по количеству, так 
и по порядку следования).

Перегрузка конструктора позволяет установить различные способы начальной инициализации объектов класса.

Если был создан конструктор, принимающий аргументы, а нам нужен конструктор по умолчанию (без аргументов), 
то его нужно создать явно.

[к оглавлению](#OOP)

## 7. Что такое статический метод?

**Статический метод** - это метод, который можно вызвать без создания объекта, напрямую через имя класса.

[к оглавлению](#OOP)

## 8. Что такое не статический метод?

**Не статический метод** - это метод, для работы которого необходим объект. Т.е. он принадлежит объекту класса и 
может быть вызван с помощью ссылки на данный объект.

Важно:

+ Статичекий метод нельзя переопределять. Он "один" для класса и его наследников.

+ Статические методы могут ссылаться только на статические переменные. Это гарантирует, что во время выполнения нашего 
метода все элементы будут инициализированы и будут работать. Это называется "статическим контекстом".

+ В отличие от локальных переменных статические поля и методы не потокобезопасны в Java.

[к оглавлению](#OOP)

## 9. Для чего используется ключевое слово this?

`this` - это неявный первый параметр любого нестатического метода класса. 
У какого объекта вызывается метод, тот и будет передан в качестве параметра `this`.

соответственно, `this` используется:

1. в теле любого метода для ссылки на текущий объект, чтобы обращаться к полям и методам данного класса. 
Например, когда у переменной экземпляра и переменной метода\конструктора одинаковые имена.
```java
class Student {
    int age;
    Student (int age) {
        this.age = age;
    }
}
```
2. когда нужно вызвать один конструктор из другого (например, конструктор по умолчанию вызывается в параметризированном). 
Вызов `this()` может находиться только в первой строке конструктора.
```java
public class Toy {
    String name;
    int cost;
    String manufacturer;
    int age;

    public Toy(String name, int cost, String manufacturer, int age) {
        this(name, cost, manufacturer);
        this.age = age;
        System.out.println("В конструкторе с четырьмя параметрами");
    }

    public Toy(String name, int cost, String manufacturer) {
        this();
        this.name = name;
        this.cost = cost;
        this.manufacturer = manufacturer;
        System.out.println("В конструкторе с тремя параметрами");
    }

    public Toy() {
        System.out.println("В конструкторе по умолчанию");
    }
}
public class ToyDemo {
    public static void main(String[] args) {
        Toy toy = new Toy("Кукла", 34, "Disney", 3);
    }
}
```
вывод:
```
В конструкторе по умолчанию
В конструкторе с тремя параметрами
В конструкторе с четырьмя параметрами
```

[к оглавлению](#OOP)

## 10. Какой класс является базовым родительским классом для всех классов?

`Object` - корневой класс в иерархии классов Java. 

Все непримитивные типы, включая массивы, наследуют прямо или косвенно от него.
Поэтому ссылочная переменная класса `Object` может ссылаться на объект любого другого класса.

Ключевое слово `super` представляет текущий экземпляр родительского класса.

[к оглавлению](#OOP)

## 11. Что такое наследование Приведите примеры из реальной жизни?

Это когда один объект перенимает все публичные поля и методы другого объекта. 

Автомобили -> Легковые -> Модель1, Модель2.

Млекопитающие -> Киты -> Голубой кит, горбатый кит.

[к оглавлению](#OOP)

## 12. Опишите процесс создания нового объекта?

https://javarush.ru/quests/lectures/questsyntax.level02.lecture03

Объект создается с помощью ключевого слова `new`, которое вызывает конструктор класса, который инициализирует начальное 
состояние объекта.
— Чтобы создать какой-нибудь объект, нужно написать имя типа (класс) этого объекта и ключевое слово new перед ним. Допустим, у нас есть класс «кот» – Cat, тогда:

```java
* Cat cat;	Объявляет ссылочную переменную с именем cat и типом Cat. Значение переменной cat – ссылка null.
* new Cat();	Создаёт объект типа Cat.
* Cat cat = new Cat();	Создаёт ссылочную переменную cat типа Cat. Создаёт новый объект типа Cat. Присваивает в переменную cat ссылку на новосозданный объект.
```
```java
* Cat murzik = new Cat();
* Cat vaska = new Cat();	
Создаются два объекта, ссылки на которые присваиваются двум разным переменным соответственно.
```

```java
* Cat murzik = new Cat();
* Cat vaska = new Cat();
* vaska = murzik;	
Создаются два объекта, ссылки на которые присваиваются двум разным переменным. Затем, переменной vaska присваивается ссылка на объект, содержащийся в переменной murzik. Теперь обе переменных ссылаются на первый созданный объект.
(На второй больше никто не ссылается – второй объект считается мусором)
```

```java
* Cat murzik = new Cat();
* Cat vaska = null;
* vaska = murzik;
* murzik = null;	
Создаётся один объект типа Cat, ссылка на который заносится в первую переменную (murzik), вторая переменная (vaska) содержит пустую (нулевую) ссылку.
Обе переменных ссылаются на один объект. Теперь только vaska ссылается на объект, но не murzik.
```
[к оглавлению](#OOP)

## 13. Как вызвать метод из родительского класса?

Если метод родительского класса переопределен, а нужно вызвать оригинальную версию метода, то нужно 
использовать ключевое слово `super`, которое представляет текущий экземпляр родительского класса.

[к оглавлению](#OOP)

## 14. Что такое переопределение метода?

Это возможность задать методу родительского класса другой функционал. 

При этом сигнатура (имя метода плюс параметры, причем порядок параметров имеет значение) метода и тип возвращаемого 
значения должны совпадать с сигнатурой и типом возврата в базовом классе.

https://habr.com/ru/company/otus/blog/347900/

[к оглавлению](#OOP)

## 15. Можно ли переопределить статический метод?

Нет, статический метод создается при инициализации класса один на все объекты.

[к оглавлению](#OOP)

## 16. Что такое виртуальная функция и используются ли они в Java?

**Виртуальная функция** - это функция (метод), которая может быть переопределена наследником.
 
В Java практически все функции виртуальные (`private` функции не могут быть переопределены в связи с правами видимости)

[к оглавлению](#OOP)

## 17. Что такое перегрузка метода?

**Перегрузка метода** - это наличие в классе нескольких методов с одним именем, но разными наборами параметров.

Перегрузить можно не только метод, но и конструктор.

При вызове перегруженного метода компилятор автоматически определяет нужный вариант метода по его параметрам, которые 
указываются при вызове.

[к оглавлению](#OOP)

## 18. Можно ли изменить тип возвращаемых тип данных при перегрузке метода?

Можно, если списки аргументов отличаются, иначе JVM не поймет какой метод ей нужно вызвать.

Т.е. если меняем тип возвращаемого значения, то мы также должны изменить список аргументов перегружаемого метода.

https://habr.com/ru/company/otus/blog/347900/

[к оглавлению](#OOP)

## 19. Что такое множественное наследование Как его можно реализовать в Java?

Множественное наследование - это наследование класса от нескольких суперклассов одновременно. 

В Java запрещено множественное наследование главным образом из-за ромбовидной проблемы. 

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/oop_1.png)

возникает неоднозначность: если метод класса D вызывает метод класса А (и этот метод не переопределён в классе D), 
а классы B и C по своему переопределили этот метод, то от какого класса его наследовать? от B или C?

В Java множественное наследование поддерживают интерфейсы.

Если есть необходимость использовать методы из двух разных классов, то можно воспользоваться композицией. 
Для этого в третьем классе нужно создать два необходимых объекта, добавить методы, которые 
обращаются к нужным методам этих объектов. И наследоваться от этого класса.

[к оглавлению](#OOP)

## 20. Что такое полиморфизм Приведите примеры из реальной жизни?

Полиморфизм описывают выражением: *Один интерфейс - множество реализаций.* 

**Полиморфизм** - это возможность работать с несколькими типами, как будто это один и тот же тип, 
в то же время поведение каждого типа будет уникальным в зависимости от его реализации. 

**Примеры:** 
+ Пульт управления один для разных моделей. 
+ Монетоприемник в каком-нибудь продающем автомате. 
+ Цоколь лампочки - это переменная определенного базового типа. Лампочка - созданный объект конкретного класса. 
Лампочки разные - цоколь один.

[к оглавлению](#OOP)

## 21. Что такое инкапсуляция?

**Инкапсуляция** - это сокрытие реализации объекта и отделение его внутреннего представления от внешнего.

Т.е. это скрытие полей объектов, ограничение доступа к определенным методам и полям.

[к оглавлению](#OOP)

## 22. Как реализована инкапсуляция в Java?

+ специальные методы геттеров и сеттеров.

+ модификаторы доступа - специальные слова, которые определяют доступ к данным.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/oop_2.png)

Например, модификатором доступа private скрываются поля объекта, 
и при необходимости к ним разрешается подкотрольный доступ через геттеры и сеттеры.

[к оглавлению](#OOP)

## 23. Можно ли применить модификаторы доступа к конструкторам?
Модификатор доступа конструктора определяет, какие классы в вашем приложении могут вызывать его. Например, если 
конструктор объявлен защищенным, то он может вызывать только классы в одном пакете или подклассы этого класса.
Класс может иметь несколько конструкторов, а каждый конструктор свой собственный модификатор доступа. Таким образом, 
некоторые конструкторы могут быть доступны для всех классов в вашем приложении, в то время как другие конструкторы 
доступны только для классов в том же пакете, подклассах или даже только для самого класса (частные конструкторы).

[к оглавлению](#OOP)

## 24. Что такое интерфейс?

Интерфейсы задают описание, как должен работать объект. Интерфейсы не содержат реализации.
Интерфейсы:
* 1. Не могут хранить состояния. Внутри интерфейса нельзя создать поля для сохранения в них данных.
* 2. Могут иметь множественное наследование. В java нет множественного наследования относительно классов. 
Зато в интерфейсах такая возможность есть.
* 3. Объявление методов без реализации. 
* 4. У интерфейсов нет конструкторов. 

нерфейс позволяет создавать общий тип данных для разных объектов, т.е. использование интерфейса гарантирует 
наличие определенного метода у объекта.
При реализации интерфейса класс должен реализовать все его методы.

Если у интерфейса только один абстрактный метод, перед нами функциональный интерфейс.  
 
**Абстрактный класс vs интерфейс**
 
1. Абстрактный класс содержит состояние объекта, что в интерфейсе невозможно,
т.к. поля там являются константами

2. Наследовать `extends` можно только один абстрактный класс, а реализовать `implements` интерфейсов сколько угодно. 
Интерфейс может наследовать другой интерфейс.

3. В интерфейсах нет конструкторов.

Замечание: 

Абстрактные классы используются, когда есть отношение `is-a`, т.е. класс наследник расширяет базовый абстрактный класс.
Интерфейс же могут быть реализованы разными классами, вовсе не связанными друг с другом.

Поэтому код, написанный на интерфейсах более масштабируем и его легче поддерживать.
При использовании абстрактных классов, а это всегда наследование, мы связываем наш код.

[к оглавлению](#OOP)

## 25. Какие типы исключительных ситуаций бывают?

Возникновение ошибок и непредвиденных ситуаций при выполнении программы называют исключением. В программе исключения 
могут возникать в результате неправильных действий пользователя, отсутствии необходимого ресурса на диске, или потери 
соединения с сервером по сети. Причинами исключений при выполнении программы также могут быть ошибки программирования 
или неправильное использование API. В отличие от нашего мира, программа должна четко знать, как поступать в такой 
ситуации. Для этого в Java предусмотрен механизм исключений. 
 

**`Throwable`** - суперкласс исключений. в нем вся логика. Остальные подклассы нужны для того, чтобы определить 
тип исключений:
 
+ **`Error` (unchecked)** - неустранимые (как правило) на уровне JVM проблемы. Согласно спецификации Java, 
не следует пытаться обрабатывать их в собственной программе.
https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html 

   *`OutOfMemoryError`* - ошибка переполнения памяти JVM. Программа дополнительную память всё равно не сможет обеспечить для JVM.
   ThreadDeath - вызывается при неожиданной остановке потока посредством метода `Thread.stop()`.
   
   *`StackOverflowError`* - ошибка переполнение стека. Часто возникает в рекурсивных функциях из-за неправильного условия выхода.

+ **`Exception` (checked)** - являются результатом проблем в программе, которые в принципе решаемые и предсказуемые.
Они обязательны для обработки и обычно связаны с бизнес-логикой приложения.

    + ***`IOException` (checked)*** ошибки созданные неудачными или прерванными операциями ввода-вывода.
    https://docs.oracle.com/javase/8/docs/api/java/io/IOException.html
    
    + ***`SQLException` (checked)*** ошибки доступа к базе данных или другие ошибки, связанных с работой с базами данных.
    https://docs.oracle.com/javase/8/docs/api/java/sql/SQLException.html
    
    + ***`RuntimeException` (unchecked)*** - результат некорректного программирования, компилятор не требует их обработки. 
    https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html
    
        *`IndexOutOfBoundsException`* - выбрасывается, когда индекс некоторого элемента в структуре данных (массив/коллекция) 
        не попадает в диапазон имеющихся индексов.
        
        *`NullPointerException`* - ссылка на объект, к которому вы обращаетесь хранит `null`.
        
        *`ClassCastException`* – Ошибка приведения типов. Всякий раз при приведении типов делается проверка на 
        возможность приведения (проверка осуществляется с помощью `instanceof`).
        
        *`ArithmeticException`* - бросается когда выполняются недопустимые арифметические операции, например деление на ноль.  

**Проверяемые исключения (checked)** - это те исключения, которые проверяются при компиляции. 
Если вы не обработаете их, вы получите ошибку компиляции.

**Непроверяемые исключения (unchecked)** - это те исключения, которые не проверяются во время компиляции. 
JVM не будет «ругаться», если вы не обработаете такие исключения.

http://javastudy.ru/interview/exceptions/

http://java-online.ru/java-throws.xhtml

http://www.quizful.net/post/java-exceptions#targetText=%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F%20%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9,%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%20java.lang.Throwable.&targetText=%D0%9F%D1%80%D1%8F%D0%BC%D1%8B%D0%BC%D0%B8%20%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA%D0%B0%D0%BC%D0%B8%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%20Throwable%20%D1%8F%D0%B2%D0%BB%D1%8F%D1%8E%D1%82%D1%81%D1%8F,%D0%B2%D0%BE%D0%B7%D0%BD%D0%B8%D0%BA%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D0%B2%D0%BE%20%D0%B2%D1%80%D0%B5%D0%BC%D1%8F%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F.

В Java есть пять ключевых слов для работы с исключениями:

+ `try` — используется для отметки начала блока кода, который потенциально может привести к ошибке.

+ `catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
Последовательность блоков catch должна идти от частного к более общему. В противном случае будет ошибка компиляции.

+ `finally` — ключевое слово для отметки начала блока кода, которой является дополнительным. 
Этот блок помещается после последнего блока `catch`. Управление обычно передаётся в блок `finally` в любом случае.

+ `throw` — служит для генерации исключений.

+ `throws` — ключевое слово, которое прописывается в сигнатуре метода, и обозначающее,
 что метод потенциально может выбросить исключение с указанным типом.

Общий вид конструкции для «поимки» исключительной ситуации выглядит следующим образом:

Для обработки исключений используется конструкция `try-catch-finally` и c 7й Java `try-with-resources`. 

**`try-catch-finally`**:
```java
try { 
    //здесь код, который потенциально может привести к ошибке 
} 
catch(SomeException e) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //здесь описываются действия, направленные на обработку исключений 
} 
finally { 
    //выполняется в любом случае (блок finally  не обязателен) 
}
```
Пример 1.
```java
try{ 
    fis = new FileInputStream(fileName); 
} catch (Exception ex) {    
    //... 
} catch (IOException e) { 
    //... 
} 
```

[к оглавлению](#OOP)

## 26. Назовите основные методы класса Object?

+ `public native int hashCode()` — возвращает хеш-код объекта.

+ `public boolean equals(Object obj)` — сравнивает объекты.

+ `public String toString()` — возвращает строковое представление объекта.

+ `public final native Class getClass()` — возвращает в рантайме класс данного объекта.

+ `protected native Object clone() throws CloneNotSupportedException` — клонирование объекта

+ `public final native void notify()` — просыпается один поток, который ждет на "мониторе" данного объекта.

+ `public final native void notifyAll()` — просыпаются все потоки, которые ждут на "мониторе" данного объекта.

+ `public final native void wait(long timeout) throws InterruptedException` — поток переходит в режим ожидания в 
течение указанного времени.

+ `public final void wait() throws InterruptedException` — приводит данный поток в ожидание, пока другой поток 
не вызовет `notify()` или `notifyAll()` методы для этого объекта.

+ `public final void wait(long timeout, int nanos) throws InterruptedException` — приводит данный поток в ожидание, 
пока другой поток не вызовет `notify()` или `notifyAll()` для этого метода, или пока не истечет указанный промежуток времени.

+ `protected void finalize() throws Throwable` — вызывается сборщиком мусора, когда garbage collector определил, 
что ссылок на объект больше нет.

Модификатор `native` сигнализирует о том, что метод реализован в платформо-зависимом коде, часто на языке С.

http://javastudy.ru/interview/java-oop3/

[к оглавлению](#OOP)

## 27. Что такое шаблоны проектирования ?
Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет 
собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить 
под нужды вашей программы.
Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если 
алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может 
отличаться в двух разных программах.

https://refactoring.guru/ru/design-patterns/what-is-pattern


[к оглавлению](#OOP)

https://job4j.ru/edu/task?action=task&taskId=0873958f75d4d2b00175d4d9a29102e7&number=410743

## 28. Объясните шаблон декоратор ?
Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую 
функциональность, оборачивая их в полезные «обёртки».
Проблема
Вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления
о важных событиях.
Основой библиотеки является класс Notifier с методом send, который принимает на вход строку-сообщение и высылает её всем 
администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять 
оповещения, а затем использовать его каждый раз, когда что-то случается.
В какой-то момент стало понятно, что одних email-оповещений пользователям мало. Некоторые из них хотели бы получать 
извещения о критических проблемах через SMS. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные 
пользователи хотели бы видеть сообщения в Slack.
Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса Notifier. Теперь 
пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.
Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме 
начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли?
Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток 
классов, стало ясно, что такой подход невероятно раздувает код программы.

Решение
Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее 
поведение. Но механизм наследования имеет несколько досадных проблем.
Он статичен. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав 
другой подкласс.Он не разрешает наследовать поведение нескольких классов одновременно. Из-за этого вам приходится 
создавать множество подклассов-комбинаций для получения совмещённого поведения. Одним из способов обойти эти проблемы 
является замена наследования агрегацией либо композицией . Это когда один объект содержит ссылку на другой и делегирует 
ему работу, вместо того чтобы самому наследовать его поведение. Как раз на этом принципе построен паттерн Декоратор.
Декоратор имеет альтернативное название — обёртка. Оно более точно описывает суть паттерна: вы помещаете целевой объект 
в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.
Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или 
обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение 
всех обёрток сразу.В примере с оповещениями мы оставим в базовом классе простую отправку по электронной почте, а 
расширенные способы отправки сделаем декораторами. Сторонняя программа, выступающая клиентом, во время первичной 
настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу оповещения. 
Последняя обёртка в списке и будет тем объектом, с которым клиент будет работать в остальное время. Для остального 
клиентского кода, по сути, ничего не изменится, ведь все обёртки имеют точно такой же интерфейс, что и базовый класс 
оповещений. Таким же образом можно изменять не только способ доставки оповещений, но и форматирование, список адресатов 
и так далее. К тому же клиент может «дообернуть» объект любыми другими обёртками, когда ему захочется. Любая одежда — 
это аналог Декоратора. Применяя Декоратор, вы не меняете первоначальный класс и не создаёте дочерних классов. Так и с 
одеждой — надевая свитер, вы не перестаёте быть собой, но получаете новое свойство — защиту от холода. Вы можете пойти 
дальше и надеть сверху ещё один декоратор — плащ, чтобы защититься и от дождя.

https://refactoring.guru/ru/design-patterns/decorator

[к оглавлению](#OOP)


## 29. Объясните шаблон Стратегия?
Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый 
из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
Проблема
Вы решили написать приложение-навигатор для путешественников. Оно должно показывать красивую и удобную карту, 
позволяющую с лёгкостью ориентироваться в незнакомом городе.
Одной из самых востребованных функций являлся поиск и прокладывание маршрутов. Пребывая в неизвестном ему городе, 
пользователь должен иметь возможность указать начальную точку и пункт назначения, а навигатор — проложит оптимальный путь.
Первая версия вашего навигатора могла прокладывать маршрут лишь по дорогам, поэтому отлично подходила для путешествий на
автомобиле. Но, очевидно, не все ездят в отпуск на машине. Поэтому следующим шагом вы добавили в навигатор прокладывание
пеших маршрутов.
Через некоторое время выяснилось, что некоторые люди предпочитают ездить по городу на общественном транспорте. Поэтому 
вы добавили и такую опцию прокладывания пути.
Но и это ещё не всё. В ближайшей перспективе вы хотели бы добавить прокладывание маршрутов по велодорожкам. А в 
отдалённом будущем — интересные маршруты посещения достопримечательностей.
Если с популярностью навигатора не было никаких проблем, то техническая часть вызывала вопросы и периодическую головную 
боль. С каждым новым алгоритмом код основного класса навигатора увеличивался вдвое. В таком большом классе стало 
довольно трудно ориентироваться.
Любое изменение алгоритмов поиска, будь то исправление багов или добавление нового алгоритма, затрагивало основной 
класс. Это повышало риск сделать ошибку, случайно задев остальной работающий код.
Кроме того, осложнялась командная работа с другими программистами, которых вы наняли после успешного релиза навигатора. 
Ваши изменения нередко затрагивали один и тот же код, создавая конфликты, которые требовали дополнительного времени на 
их разрешение.

Решение
Паттерн Стратегия предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести 
их в собственные классы, называемые стратегиями.
Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль контекста, ссылаясь на 
одну из стратегий и делегируя ей выполнение работы. Чтобы сменить алгоритм, вам будет достаточно подставить в контекст 
другой объект-стратегию. Важно, чтобы все стратегии имели общий интерфейс. Используя этот интерфейс, контекст будет 
независимым от конкретных классов стратегий. С другой стороны, вы сможете изменять и добавлять новые виды алгоритмов, 
не трогая код контекста.
В нашем примере каждый алгоритм поиска пути переедет в свой собственный класс. В этих классах будет определён лишь один 
метод, принимающий в параметрах координаты начала и конца пути, а возвращающий массив точек маршрута.
Хотя каждый класс будет прокладывать маршрут по-своему, для навигатора это не будет иметь никакого значения, так как его
абота заключается только в отрисовке маршрута. Навигатору достаточно подать в стратегию данные о начале и конце 
маршрута, чтобы получить массив точек маршрута в оговорённом формате.
Класс навигатора будет иметь метод для установки стратегии, позволяя изменять стратегию поиска пути на лету. Такой метод 
пригодится клиентскому коду навигатора, например, переключателям типов маршрутов в пользовательском интерфейсе.
Вам нужно добраться до аэропорта. Можно доехать на автобусе, такси или велосипеде. Здесь вид транспорта является
стратегией. Вы выбираете конкретную стратегию в зависимости от контекста — наличия денег или времени до отлёта.
Подробнее:
https://refactoring.guru/ru/design-patterns/strategy

https://qna.habr.com/q/756609

[к оглавлению](#OOP)

## Collections Lite

[1. Что такое коллекция?](#1-Что-такое-коллекция)

[2. Назовите преимущества использования коллекций?](#2-Назовите-преимущества-использования-коллекций)

[3. Какие данные могут хранить коллекции?](#3-Какие-данные-могут-хранить-коллекции)

[4. Какие есть типы коллекций? Как они характеризуются?](#4-Какие-есть-типы-коллекций-Как-они-характеризуются)

[5. Назовите основные реализации List, Set, Map?](#5-Назовите-основные-реализации-List,-Set,-Map)

[6. В чём отличие ArrayList от LinkedList?](#6-В-чём-отличие-ArrayList-от-LinkedList)

[7. В чём отличие HashSet от TreeSet?](#7-В-чём-отличие-HashSet-от-TreeSet)

[8. В чём отличие Set от Map?](#8-В-чём-отличие-Set-от-Map)

[9. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?](#9-Как-задается-порядок-следования-объектов-в-коллекции-Как-отсортировать-коллекцию)

[10. Чем отличается Comparable от Comparator?](#10-Чем-отличается-Comparable-от-Comparator)

[11. Что такое сортировка по принципу Natural Order?](#11-Что-такое-сортировка-по-принципу-Natural-Order)

[12. Что такое equals и hashcode?](#12-Что-такое-equals-и-hashcode)

[13. Какие есть способы перебора всех элементов List?](#13-Какие-есть-способы-перебора-всех-элементов-List)

[14. Как реализован цикл foreach?](#14-Как-реализован-цикл-foreach)

[15. В чем разница между Iterator и ListIterator?](#15-В-чем-разница-между-Iterator-и-ListIterator)

[16. Как происходит удаление элементов из ArrayList?](#16-Как-происходит-удаление-элементов-из-ArrayList)

[17. Как происходит удаление элементов из LinkedList?](#17-Как-происходит-удаление-элементов-из-LinkedList)

## 1. Что такое коллекция?

**Коллекции** - это хранилища, поддерживающие различные способы накопения и упорядочивания объектов с целью обеспечения 
эффективного доступа к ним.

Они представляют собой реализации абстрактных структур данных, поддерживающих различные способы хранения данных, а также
операции добавления, удаления и изменения элементов. Т.е. это набор интерфейсов и реализующих их классов.

[к оглавлению](#collections-lite)

## 2. Назовите преимущества использования коллекций?

+ отсутствует необходимость следить за размерами коллекции (в отличае от массива);

+ позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано 
много методов по добавлению, удалению, сортировке элементов и т.п.;

+ если правильно подобрать коллекцию, то можно увеличить производительность программы;

+ упрощают взаимодействие разных частей программы, т.к. являются универсальным способом хранения и передачи данных.

[к оглавлению](#collections-lite)

## 3. Какие данные могут хранить коллекции?

Коллекции могут хранить любые ссылочные типы данных.

[к оглавлению](#collections-lite)

## 4. Какие есть типы коллекций Как они характеризуются?

+ **Set** - множество неповторяющихся элементов (Здесь могут храниться только уникальные значения, нет дубликатов)

+ **Queue** (Deque) - коллекция, предназначенная для хранения элементов в порядке, нужном для их обработки. В дополнение к базовым операциям интерфейса Collection, очередь предоставляет дополнительные операции вставки, получения и контроля.

Очереди обычно, но не обязательно, упорядочивают элементы в FIFO (first-in-first-out, “первым вошел – первым вышел”) порядке. Реализует LinkedList

+ **List** - упорядоченный список (В какой последовательности данные положили, в такой они и хранятся.
Допускаются дубликаты.)

+ **Map** - карта, ассоциативный массив (Значения хранятся в виде пар ключ=значение. Каждому элементу из множества
ключей соответствует множество значений. Ключи уникальные. По ключу получаем значение. У мапы нет итератора. 
Map не наследуется от Collection.) 

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#collections-lite)

## 5. Назовите основные реализации List, Set, Map?

+ **List:** ArrayList, LinkedList

+ **Set:** HashSet, LinkedHashSat, TreeSet

+ **Map:** HashMap, LinkedHashMap, TreeMap

[к оглавлению](#collections-lite)

## 6. В чём отличие ArrayList от LinkedList?

**ArrayList - основан на динамическом массиве**, хранит свои элементы в массиве. 
(используют, если элементы чаще читаются, чем добавляются)

**+** Быстрая навигация по коллекции - осуществляется быстрый поиск элементов;

**+** меньше расходует памяти на хранение элементов;

**-** увеличение `ArrayList` происходит медленно;

**-** при вставке или удалении элемента в середину или в начало, приходится переписывать все элементы;

**LinkedList - двунаправленный список (цепочка)**, хранит элементы в объектах `Node<E>`, у которых есть ссылки на 
предыдущий и следующий элементы (используют, если элементы чаще добавляются, чем читаются) 

**+** быстрая вставка и удаление в середину списка (переписать `next` и `previous` и всё);

**-** долгий поиск в середине (нужно перебрать все элементы);

Очевидно, что плюсы одного являются минусами второго.
В среднем, сложности одинаковые, но все же `ArrayList` предпочтительнее использовать. 
`LinkedList` рекомендуется использовать, только когда преобладает удаление или вставка в начало или конец списка.

[к оглавлению](#collections-lite)

## 7. В чём отличие HashSet от TreeSet?

**Set** - множество неповторяющихся элементов.

**HashSet** хранит данные в произвольном порядке (хранит свои значения как ключи `HashMap`).

**TreeSet** хранит данные в отсортированном виде (в основе реализации бинарное красно-черное дерево).

[к оглавлению](#collections-lite)

## 8. В чём отличие Set от Map?

сет это список ключей от мапы.

[к оглавлению](#Collections-Lite)

## 9. Как задается порядок следования объектов в коллекции Как отсортировать коллекцию?

Порядок задается либо естественным следованием элементов (natural order), 
либо объектом, реализующим интерфейс сравнения `Comparator`.

Можно отсортировать с помощью интерфейса `Comparable` или интерфейса `Comparator`:
 
+ Если объекты коллекции поддерживают интерфейс `Comparable`, то через `Collections.sort(collection)`; 

+ Если нет, то у коллекции вызвать метод `sort()` и передать ему `Comparator` в качестве аргумента `collection.sort(new MyComparator())`.
Либо использовать метод `Collections.sort(collection, new MyComparator())`.

[к оглавлению](#collections-lite)

## 10. Чем отличается Comparable от Comparator?

**Comparable** - используется только для сравнения объектов класса, в котором данный интерфейс реализован. 
Т.е. интерфейс `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей 
реализации (по правилам разработчика). 
`Collections.sort(collection);`

**Comparator** - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. 
Т.е. интерфейс `Comparator` позволяет создавать объекты, которые будут управлять процессом сравнения: 
1. при сортировках в методах `Collections.sort(collection, new MyComparator())`, `Arrays.sort(array, new MyComparator())` 
или `collection.sort(new MyComparator())`
2. при управлении порядком в отсортированных множествах `TreeSet` или отсортированных картах `TreeMap`,
 например `new TreeSet<T> (new MyComparator())`.

**Разница:**

+ `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации 
и, если нет доступа к исходникам, ее невозможно изменить. 

+ `Comparator` позволает определить логику сравнения объектов определенного ссылочного типа вне реализации 
этого типа и эту логику можно в любой момент подменить.

*`Comparable` используется для `natural ordering`, а `Comparator` для `total ordering`.*

**Примеры:**

http://java-online.ru/blog-comparator.xhtml

https://netjs.blogspot.com/2015/10/difference-between-comparable-and-comparator-java.html

https://www.programcreek.com/2011/12/examples-to-demonstrate-comparable-vs-comparator-in-java/

[к оглавлению](#collections-lite)

## 11. Что такое сортировка по принципу Natural Order?

Некоторые классы из коробки реализуют естественный порядок `natural order` для сортировки:

+ строки - лексикографический (по алфавиту),
+ числа - числовой, знаковый или без (больше меньше),
+ дата - хронологичский (по датам),
+ файл - лексикографический по имени пути
+ boolean - false < true

Остальные классы нужно руками делать `Comparable` или `Comparator`.

[к оглавлению](#collections-lite)

## 12. Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов. 

`hashcode` возвращает число, являющееся уникальным идентификатором объекта. 
Это алгоритм, который позволяет множество значений объектов сузить до какого-то натурального количества.
 
`equals` сравнивает объекты по значению их полей. 

Объекты всех коллекций в названии которых есть *Hash...* должны иметь `hashcode` и `equals`.

[к оглавлению](#collections-lite)

## 13. Какие есть способы перебора всех элементов List?

Есть список стран, его нужно перебрать
```java
List<String> countries = Arrays.asList("Russia", "Panama", "Australia");
```
+ **циклы** `for`, `while`, `foreach`

```java
for (int i = 0; i < countries.size(); i++) {
    System.out.println(countries.get(i));
}
```

```java
int i = 0;
while (i < countries.size()){
    System.out.println(countries.get(i++));
}
```

```java
for (String country : countries) {
    System.out.println(country);
}    
```

+ **итераторы** `Iterator`, `ListIterator`
```java
Iterator<String> countriesIterator = countries.iterator();
while(countriesIterator.hasNext()) {
    System.out.println(countriesIterator.next());
}
```

```java
ListIterator<String> listIterator = countries.listIterator();
//в прямом порядке
while(listIterator.hasNext()) {
    System.out.println(listIterator.next());
}
//в обратном порядке
while(listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
}    
```
Если вызвать метод `next()` итератора, указывающего на последний элемент в коллекции, 
то возникнет исключение `NoSuchElementException`. Следует это помнить и использовать метод `hasNext()` перед вызовом `next()`.

+ **функция `forEach()`** 
    
    + **`Iterable.forEach()`** можно использовать для итерации по элементам списка начиная с Java 8. 
Этот метод определен в интерфейсе Iterable и может принимать лямбда-выражения в качестве параметра.
    ```java
    countries.forEach(System.out::println);
    ```
    
    + **`Stream.forEach()`** Мы также можем преобразовать коллекцию значений в поток и получить доступ 
    к таким операциям, как `forEach()`, `map()`, или `filter()`.
    ```java
    countries.stream().forEach(
        (c) -> System.out.println(c)
    );
    ```
    
https://www.codeflow.site/ru/article/java-iterate-list    

[к оглавлению](#collections-lite)

## 14. Как реализован цикл foreach?

`foreach` реализован на основе `Iterator`, т.е. он работает для классов, реализующих интерфейс `Iterable`.

(И наоборот, если коллекция `extends` от `Iterable`, то мы можем перебирать элементы этой коллекции с помощью `foreach`)

[к оглавлению](#collections-lite)

## 15. В чем разница между Iterator и ListIterator?

`ListIterator` расширяет `Iterator`, отличия следующие:

+ `Iterator` может использоваться для перебора элементов коллекций `Set`, `List` и `Map`. 
`ListIterator` может быть использован только для перебора элементов коллекции `List`

+ `Iterator` позволяет перебирать элементы только в одном направлении, при помощи метода `next()`. 
`ListIterator` позволяет перебирать список в обоих направлениях, при помощи методов `next()` и `previous()`.

+ `ListIterator` позволяет модифицировать список, добавляя/заменяя/удаляя элементы с помощью методов `add()`, `set()`
`remove()`. Iterator не поддерживает данного функционала.

[к оглавлению](#collections-lite)

## 16. Как происходит удаление элементов из ArrayList?

Находится заданный элемент. 
Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а значение `size` уменьшается на 1.

Непосредственно под капотом: 
```java
System.arraycopy(es, i + 1, es, i, newSize - i)
es[size = newSize] = null;
```

[к оглавлению](#collections-lite)

## 17. Как происходит удаление элементов из LinkedList?

Заменяются ссылки `previous` и `next` у соседних элементов.

[к оглавлению](#collections-lite)
